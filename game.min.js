"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LinesAnimation = /*#__PURE__*/function () {
  function LinesAnimation(ctx, lps, mixedColors) {
    _classCallCheck(this, LinesAnimation);

    this.ctx = ctx;
    this.loaded = false;
    this.isPlaying = false;
    this.drawings = [];
    this.layers = [];
    this.currentFrame = 0;
    this.currentFrameCounter = 0; // floats

    this.lps = lps || 12;
    this.fps = lps || 12;
    this.lineInterval = 1000 / this.lps;
    this.intervalRatio = 1;
    this.mixedColors = mixedColors || true;
    this.rndr = {
      off: {
        x: 0,
        y: 0
      },
      speed: {
        x: 0,
        y: 0
      }
    };
    this._state = 'default';
    this.states = {
      'default': {
        start: 0,
        end: 0
      }
    };
    this.over = {};
    this.override = true;
  }

  _createClass(LinesAnimation, [{
    key: "overrideProperty",
    value: function overrideProperty(prop, value) {
      this.over[prop] = value;
      this.override = true;
    }
  }, {
    key: "cancelOverride",
    value: function cancelOverride() {
      this.over = {};
      this.override = false;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isPlaying) {
        if (this.currentFrame <= this.currentState.end) {
          this.currentFrameCounter += this.intervalRatio;
          this.currentFrame = Math.floor(this.currentFrameCounter);
          if (this.onUpdate) this.onUpdate();
        } // console.log(this.frame4, this.currentState.end, this.currentState.end + 1 - this.intervalRatio, this.frame4 > this.currentState.end + 1 - this.intervalRatio);
        // console.log(this.frame4, this.currentState.end + 1);

        /* fuck me */


        if (this.frame4 >= this.currentState.end + 1) {
          this.frame = this.currentState.start;
          /* loop ? */

          if (this.onPlayedState) this.onPlayedState();
        }

        if (this.onUpdate) this.onUpdate();
      }
    }
  }, {
    key: "draw",
    value: function draw(x, y) {
      // if (this.debug) console.log(x, y);
      if (!this.mixedColors) this.ctx.beginPath();

      for (var i = 0, len = this.layers.length; i < len; i++) {
        var layer = this.layers[i];
        var drawing = this.drawings[layer.d];

        if (this.currentFrame >= layer.f.s && this.currentFrame <= layer.f.e) {
          this.rndr.s = 0;
          this.rndr.e = drawing.length;

          for (var key in layer) {
            this.rndr[key] = layer[key];
          }

          if (x) this.rndr.x += x;
          if (y) this.rndr.y += y;

          if (layer.t) {
            for (var j = 0; j < layer.t.length; j++) {
              var tween = layer.t[j];

              if (tween.sf <= this.currentFrame && tween.ef >= this.currentFrame) {
                this.rndr[tween.prop] = Cool.map(this.currentFrame, tween.sf, tween.ef, tween.sv, tween.ev);
                if (tween.prop == 's' || tween.prop == 'e') this.rndr[tween.prop] = Math.round(this.rndr[tween.prop]);
              }
            }
          }

          if (this.override) {
            for (var _key in this.over) {
              this.rndr[_key] = this.over[_key];
            }
          }

          if (this.rndr.w > 0) {
            this.rndr.off.x = Cool.random(0, this.rndr.w); // random start of wiggle offset

            this.rndr.off.y = Cool.random(0, this.rndr.w);
            this.rndr.speed.x = Cool.random(-this.rndr.v, this.rndr.v);
            this.rndr.speed.y = Cool.random(-this.rndr.v, this.rndr.v);
          } else {
            this.rndr.off.x = 0;
            this.rndr.off.y = 0;
            this.rndr.speed.x = 0;
            this.rndr.speed.y = 0;
          }

          if (this.mixedColors) this.ctx.beginPath();

          for (var _j = this.rndr.s; _j < this.rndr.e - 1; _j++) {
            var s = drawing[_j];
            var e = drawing[_j + 1];
            var v = new Cool.Vector(e.x, e.y);
            v.subtract(s);
            v.divide(this.rndr.n);
            this.ctx.moveTo(this.rndr.x + s.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x, this.rndr.y + s.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y);

            for (var k = 0; k < this.rndr.n; k++) {
              var p = new Cool.Vector(s.x + v.x * k, s.y + v.y * k);
              this.ctx.lineTo(this.rndr.x + p.x + v.x + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.x, this.rndr.y + p.y + v.y + Cool.random(-this.rndr.r, this.rndr.r) + this.rndr.off.y);

              if (k == 0 || this.rndr.ws) {
                if (this.rndr.w > 0) {
                  for (var xy in this.rndr.off) {
                    this.rndr.off[xy] += this.rndr.speed[xy];

                    if (this.rndr.off[xy] >= this.rndr.w || this.rndr.off[xy] <= -this.rndr.w) {
                      this.rndr.speed[xy] *= -1;
                    }
                  }
                }
              }
            }

            if (this.ctx.strokeStyle != this.rndr.c && this.mixedColors) this.ctx.strokeStyle = this.rndr.c;
          }

          if (this.mixedColors) this.ctx.stroke();
        }
      }

      if (!this.mixedColors) this.ctx.stroke();
      if (this.onDraw) this.onDraw();
    }
  }, {
    key: "load",
    value: function load(src, callback) {
      var _this = this;

      fetch(src).then(function (response) {
        return response.json();
      }).then(function (data) {
        _this.loadData(data, callback);
      })["catch"](function (error) {
        console.error(error);
      });
    }
  }, {
    key: "loadJSON",
    value: function loadJSON(json, callback) {
      this.loadData(json, callback);
    }
  }, {
    key: "loadData",
    value: function loadData(json, callback) {
      this.loaded = true; // console.time('load drawings');
      // console.log(json.d.length);
      // console.log(json);

      for (var i = 0; i < json.d.length; i++) {
        var drawing = json.d[i];
        var d = void 0;

        if (drawing) {
          d = [];

          for (var j = 0; j < drawing.length; j++) {
            var point = drawing[j];
            if (point) d.push({
              x: point[0],
              y: point[1]
            });else d.push('end');
          }
        } else {
          d = null;
        }

        this.drawings[i] = d;
      } // console.timeEnd('load drawings');


      this.layers = json.l;

      for (var key in json.s) {
        this.states[key] = json.s[key];
      }

      if (this.states["default"]) this.states["default"].end = this.endFrame;
      this.intervalRatio = this.lineInterval / (1000 / json.fps);
      if (json.mc) this.mixedColors = json.mc;
      /* hmm .. over ride? */
      // this.isPlaying = true; /* off for animate ? */

      /* need width and height for infinite hell */

      this.width = json.w;
      this.height = json.h;
      if (callback) callback(json);
      if (this.onLoad) this.onLoad();
    }
  }, {
    key: "setOnLoad",
    value: function setOnLoad(callback) {
      if (this.loaded) callback();else this.onLoad = callback;
    }
  }, {
    key: "fps",
    set: function set(fps) {
      this._fps = +fps;
      this.intervalRatio = this.lineInterval / (1000 / +fps);
    },
    get: function get() {
      return this._fps;
    }
  }, {
    key: "lps",
    set: function set(lps) {
      this._lps = +lps;
      this.lineInterval = 1000 / +lps;
      this.intervalRatio = this.lineInterval / (1000 / this.fps);
    },
    get: function get() {
      return this._lps;
    }
  }, {
    key: "frame",
    set: function set(n) {
      this.currentFrame = this.currentFrameCounter = +n;

      if (this.states["default"]) {
        if (this.states["default"].end != this.endFrame) this.states["default"].end = this.endFrame;
      }
    }
  }, {
    key: "frame4",
    get: function get() {
      return +this.currentFrameCounter.toFixed(4);
    }
  }, {
    key: "endFrame",
    get: function get() {
      return this.layers.length > 0 ? Math.max.apply(Math, this.layers.map(function (layer) {
        return layer.f.e;
      })) : 0;
    }
  }, {
    key: "currentState",
    get: function get() {
      return this.states[this.state];
    }
  }, {
    key: "state",
    set: function set(state) {
      if (this._state != state && this.states[state]) {
        this._state = state;
        if (this.currentState) this.frame = this.currentState.start;
        /* bad temp fix ... for what? 
        if (!this.isPlaying && state != 'default') 
        	this.isPlaying = true; 
        take it out until i remember
        */
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return LinesAnimation;
}();
/* questions 
	- use A/Anim to make Animation availabe in contexts?
		- only really in game
		- maybe Animation and GameAnimation
		- or Sprite Animation
		- Anim is not good ... 
	rndr	
		- wierd to rndr as only abbreivation?
		- yes used so often its okay to abbreviate
		- animate just rests every time ...
			- do i need rndr at all, just layer values and over ride?
			- yeah as is rndr is stupid because it never doesn't reset the values
				- what were issues with that?
				- 0 undefined at first but there was others ... 
				- using layers instead of frames makes this better
				- maybe keep track of layers chaning?
				- that happens with currentFrame between endFrame startFrame
				- think more on this
			- otherwise just use const
				const e = over.e !== undefined ? over.e : layer.e;
			- do some performance tests with garden


	anim/game
		- how to handle width, height ratios for resizing ...
		- loop is assumed for other anims ...
		- random frames prob only in game

	load -- issues 
		- game saves loaded sprites, not necessary for others
		- game setting sprite size
		- whole separate loader class?
	pre/post draw, needed but should be handled by sub classes?
	- onupdate - on draw

	update
		- comes at the end for game, beginning for anim and animate/play
		- does update call draw or the other way around ...

	layer class ?
		- more for interface stuff ...
		- only useful method isInFrame
		- mm ... start frame, end frame ... 
		- anim one is useful but probab not necessary for game

	range class
		- start and end
		- end can't be smaller than start
		- what about saving data???  method ... 
		- is this actually usedful? 
*/
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Button = /*#__PURE__*/function (_UI) {
  _inherits(Button, _UI);

  var _super = _createSuper(Button);

  function Button(params, debug) {
    var _this;

    _classCallCheck(this, Button);

    _this = _super.call(this, params, debug);
    _this.mouseOver = false;
    _this.waitToGoOut = false;
    _this.clickStarted = false;
    if (params.onOver) _this.onOver = params.onOver;
    if (params.onOut) _this.onOut = params.onOut;
    if (params.onDown) _this.onDown = params.onDown;
    if (params.onClick) _this.onClick = params.onClick;
    return _this;
  }

  _createClass(Button, [{
    key: "over",
    value: function over(x, y) {
      var over = _get(_getPrototypeOf(Button.prototype), "over", this).call(this, x, y);

      if (over) this.animation.state = 'over';
      return over;
    }
  }, {
    key: "out",
    value: function out(x, y) {
      var out = _get(_getPrototypeOf(Button.prototype), "out", this).call(this, x, y);

      if (out) this.animation.state = 'idle';
      return out;
    }
  }, {
    key: "down",
    value: function down(x, y) {
      var down = _get(_getPrototypeOf(Button.prototype), "down", this).call(this, x, y);

      if (down) this.animation.state = 'active';
      return down;
    }
  }, {
    key: "up",
    value: function up(x, y) {
      var up = _get(_getPrototypeOf(Button.prototype), "up", this).call(this, x, y);

      if (up) this.animation.state = 'idle';
      return up;
    }
  }]);

  return Button;
}(UI);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Entity = /*#__PURE__*/function (_Sprite) {
  _inherits(Entity, _Sprite);

  var _super = _createSuper(Entity);

  function Entity(params, src, debug) {
    var _this;

    _classCallCheck(this, Entity);

    _this = _super.call(this, params.x, params.y);
    _this.debug = debug;
    _this.origin = new Cool.Vector(params.x, params.y); // this.origin = { x: params.x, y: params.y };

    _this.center = params.center || true;
    return _this;
  }

  _createClass(Entity, [{
    key: "update",
    value: function update(offset) {
      // this.position.x = this.origin.x + offset.x;
      // this.position.y = this.origin.y + offset.y;
      this.position = this.origin.copy().add(offset.copy());
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y) {
      this.origin = new Cool.Vector(x, y); // this.origin.x = x;
      // this.origin.y = y;
    }
  }]);

  return Entity;
}(Sprite);
"use strict";

var Events = {
  init: function init(canvas) {
    var startX, startY, endX, endY, startTime;
    var dragStarted = false;
    var dragOffset;
    canvas.addEventListener('click', function (ev) {
      ev.preventDefault();
      if (typeof mouseClicked === "function") mouseClicked(ev.offsetX, ev.offsetY);
    }, false);
    canvas.addEventListener('mousedown', function (ev) {
      ev.preventDefault();
      if (typeof mouseDown === "function") mouseDown(ev.offsetX, ev.offsetY, ev.which, ev.shiftKey);

      if (typeof startDrag === "function") {
        dragOffset = startDrag(ev.offsetX, ev.offsetY);
        if (dragOffset) dragStarted = true;
      }
    }, false);
    canvas.addEventListener('mouseup', function (ev) {
      ev.preventDefault();
      if (typeof mouseUp === "function") mouseUp(ev.offsetX, ev.offsetY, ev.which);
      if (dragStarted) dragStarted = false;
    }, false);
    canvas.addEventListener('mousemove', function (ev) {
      if (typeof mouseMoved === "function") mouseMoved(ev.offsetX, ev.offsetY, ev.which);
      if (dragStarted) drag(ev.offsetX, ev.offsetY, dragOffset);
    }, false);
    document.addEventListener('keydown', function (ev) {
      if (typeof keyDown === "function" && ev.target.tagName != "INPUT") keyDown(Cool.keys[ev.which]);
    });
    document.addEventListener('keyup', function (ev) {
      if (typeof keyUp === "function" && ev.target.tagName != "INPUT") keyUp(Cool.keys[ev.which]);
    });
    window.addEventListener('resize', function (ev) {
      if (typeof sizeCanvas === "function") sizeCanvas();
    }, false);
  }
};
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Game = /*#__PURE__*/function () {
  function Game(params) {
    _classCallCheck(this, Game);

    this.canvas = document.getElementById(params.canvas || "lines");
    this.width = params.width;
    this.height = params.height;
    this.lps = params.lps;
    this.mixedColors = params.mixedColors || false;
    /* param? */

    this.debug = params.debug || false;
    this.lineInterval = 1000 / params.lps;
    this.updateTime = performance.now();
    this.updateInterval = 1000 / 60; // 60 fps

    this.drawTime = performance.now();
    this.clearBg = true;
    this.bounds = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    this.scenes = new SceneManager(params.scenes, Scene);
    this.data = {};
    this.anims = {};

    if (this.canvas.getContext) {
      this.ctx = this.canvas.getContext('2d');
      this.dpr = params.checkRetina ? window.devicePixelRatio || 1 : 1;
      this.canvas.width = this.width * this.dpr;
      this.canvas.height = this.height * this.dpr;
      this.ctx.scale(this.dpr, this.dpr);
      this.canvas.style.zoom = 1 / this.dpr;
      if (params.lineColor) this.ctx.strokeStyle = params.lineColor;
      if (params.scale) this.ctx.scale(params.scale, params.scale);
      if (params.stats) this.stats = new Stats(this.ctx, ['FPS', 'draw']);
      this.ctx.miterLimit = 1; // do this last
    }
  }

  _createClass(Game, [{
    key: "load",
    value: function load(files, callback) {
      var _this = this;

      this.assetsLoaded = {};
      var numFiles = Object.keys(files).length;

      var _loop = function _loop(f) {
        var file = files[f];
        fetch(file).then(function (response) {
          if (response.ok) return response.url.includes('csv') ? response.text() : response.json();
          throw new Error('Network response was not ok.');
        }).then(function (data) {
          _this.data[f] = {};
          _this.anims[f] = {};
          _this.assetsLoaded[f] = {};

          if (_typeof(data) == 'object') {
            _this.data[f].entries = data;

            for (var key in data) {
              _this.assetsLoaded[f][key] = false;

              _this.loadJSON(f, key, data[key].src);
            }
          } else {
            // csv item names have to match drawing names
            var csv = CSVToArray(data, ',').splice(1);
            _this.data[f].entries = csv;

            for (var i = 0; i < csv.length; i++) {
              var itemName = csv[i][0];
              _this.assetsLoaded[f][itemName] = false;

              _this.loadJSON(f, itemName, "drawings/".concat(f, "/").concat(itemName, ".json"));
            }
          }
        })["catch"](function (error) {
          console.error(error);
          _this.assetsLoaded[f] = true;
        });
      };

      for (var f in files) {
        _loop(f);
      }

      var loader = setInterval(function () {
        var loaded = Object.keys(_this.assetsLoaded).length == numFiles;

        for (var _f in _this.assetsLoaded) {
          for (var k in _this.assetsLoaded[_f]) {
            if (!_this.assetsLoaded[_f][k]) loaded = false;
          }
        }

        if (loaded) {
          clearInterval(loader); // when will this ever not be game start?
          // if (callback) callback();

          _this.start();
        }
      }, 1000 / 60);
    }
  }, {
    key: "loadJSON",
    value: function loadJSON(file, key, src) {
      var _this2 = this;

      fetch(src).then(function (response) {
        return response.json();
      }).then(function (json) {
        _this2.anims[file][key] = new GameAnim();

        _this2.anims[file][key].loadData(json, function () {
          _this2.assetsLoaded[file][key] = true;
        });
      });
    }
  }, {
    key: "start",
    value: function (_start) {
      function start() {
        return _start.apply(this, arguments);
      }

      start.toString = function () {
        return _start.toString();
      };

      return start;
    }(function () {
      var _this3 = this;

      /* 
      	draw and update are separates functions 
      	because lines draw at relatively slow rate (10fps) 
      */
      if (typeof start === "function") start(); // should be this method?

      if (typeof update === "function") requestAnimFrame(function () {
        _this3.update();
      });
      if (typeof draw === "function") requestAnimFrame(function () {
        _this3.draw();
      }); // better way to do events? 

      if (typeof Events != "undefined") Events.init(this.canvas);
    })
  }, {
    key: "draw",
    value: function (_draw) {
      function draw() {
        return _draw.apply(this, arguments);
      }

      draw.toString = function () {
        return _draw.toString();
      };

      return draw;
    }(function () {
      var _this4 = this;

      var time = performance.now();

      if (time >= this.drawTime + this.lineInterval) {
        if (this.clearBg) this.ctx.clearRect(0, 0, this.width * this.dpr, this.height * this.dpr); // add this scenes ?

        draw(); // draw defined in each this js file, or not ... 

        if (this.stats) {
          this.stats.draw();
          this.stats.update('draw', time, this.drawTime);
        }

        this.drawTime = time;
      }

      requestAnimFrame(function () {
        _this4.draw();
      });
    })
  }, {
    key: "update",
    value: function (_update) {
      function update() {
        return _update.apply(this, arguments);
      }

      update.toString = function () {
        return _update.toString();
      };

      return update;
    }(function () {
      var _this5 = this;

      var time = performance.now();

      if (time > this.updateTime + this.updateInterval) {
        update(); // update defined in each game js file

        if (this.stats) this.stats.update('FPS', time, this.updateTime);
        this.updateTime = time;
      }

      requestAnimFrame(function () {
        _this5.update();
      }); // this context
    })
  }, {
    key: "addLettering",
    value: function addLettering(animation) {
      var letterIndexString = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,:?-+'&$;\"!";

      for (var i = 0; i < letterIndexString.length; i++) {
        animation.createNewState(letterIndexString[i], i, i);
      }
    }
  }, {
    key: "setBounds",
    value: function setBounds(dir, value) {
      this.bounds[dir] = value;
    }
  }]);

  return Game;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var GameAnim = /*#__PURE__*/function (_LinesAnimation) {
  _inherits(GameAnim, _LinesAnimation);

  var _super = _createSuper(GameAnim);

  function GameAnim(src, callback, debug) {
    var _this;

    _classCallCheck(this, GameAnim);

    _this = _super.call(this, gme.ctx, gme.lps, gme.mixedColors);
    _this.debug = debug;
    _this.loop = true;
    _this.randomFrames = false;
    /* play random frames */

    return _this;
  }

  _createClass(GameAnim, [{
    key: "update",
    value: function update() {
      /* too many things to stick in onPlayedState etc */
      if (this.isPlaying) {
        if (this.currentFrame <= this.currentState.end) {
          this.currentFrameCounter += this.intervalRatio;

          if (this.randomFrames && this.currentFrame != Math.floor(this.currentFrameCounter)) {
            var prevFrame = this.currentFrame;

            while (prevFrame == this.currentFrame) {
              this.frame = Cool.randomInt(this.currentState.start, this.currentState.end);
            }
          }

          this.currentFrame = Math.floor(this.currentFrameCounter);
          if (this.onUpdate) this.onUpdate();
        }
      }

      if (this.frame4 >= this.currentState.end + 1) {
        /* not DRY fuck me */
        if (this.loop) this.frame = this.currentState.start;else this.frame = this.currentState.end;

        if (this.onPlayedOnce) {
          this.onPlayedOnce();
          this.onPlayedOnce = undefined;
        }

        if (this.onPlayedState) this.onPlayedState();
      }
    }
  }, {
    key: "createNewState",
    value: function createNewState(label, start, end) {
      if (!this.states[label]) {
        this.states[label] = {
          start: start,
          end: end
        };
      }

      this.state = label;
      /* ? */
    }
  }, {
    key: "playOnce",
    value: function playOnce(callback) {
      if (!this.isPlaying) this.isPlaying = true;
      this.frame = this.currentState.start;
      this.onPlayedOnce = callback;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.isPlaying = false;
    }
  }, {
    key: "start",
    value: function start() {
      this.isPlaying = true;
    }
  }, {
    key: "state",
    set: function set(state) {
      if (this._state != state && this.states[state]) {
        this._state = state;
        if (this.currentState) this.frame = this.currentState.start;
        if (!this.isPlaying && state != 'default') this.isPlaying = true;
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return GameAnim;
}(LinesAnimation);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Manager = /*#__PURE__*/function () {
  function Manager(list, _class) {
    _classCallCheck(this, Manager);

    for (var i = 0; i < list.length; i++) {
      this[list[i]] = new _class();
    }

    this._current = list[0];
  }

  _createClass(Manager, [{
    key: "current",
    set: function set(label) {
      this._current = label;
    },
    get: function get() {
      return this[this._current];
    }
  }]);

  return Manager;
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Scene = /*#__PURE__*/function () {
  function Scene() {
    _classCallCheck(this, Scene);

    this.displaySprites = new SpriteCollection();
    this.updateSprites = new SpriteCollection();
    this.uiSprites = new SpriteCollection();
  }

  _createClass(Scene, [{
    key: "add",
    value: function add(sprite) {
      this.displaySprites.add(sprite);
      this.updateSprites.add(sprite);
      this.uiSprites.add(sprite);
    }
  }, {
    key: "remove",
    value: function remove(sprite, type) {
      var types = type ? [type] : ['display', 'update', 'ui'];

      for (var i = 0; i < types.length; i++) {
        var index = this["".concat(types[i], "Sprites")].indexOf(sprite);
        if (index >= 0) this["".concat(types[i], "Sprites")].splice(index, 1);
      }
    }
  }, {
    key: "addSprite",
    value: function addSprite(sprite) {
      this.displaySprites.add(sprite);
      this.updateSprites.add(sprite);
    }
  }, {
    key: "addUI",
    value: function addUI(sprite) {
      this.displaySprites.add(sprite);
      this.uiSprites.add(sprite);
    }
  }, {
    key: "addToDisplay",
    value: function addToDisplay(sprite) {
      this.displaySprites.add(sprite);
    }
  }, {
    key: "addToUpdate",
    value: function addToUpdate(sprite) {
      this.updateSprites.add(sprite);
    }
  }, {
    key: "addToUI",
    value: function addToUI(sprite) {
      this.uiSprites.add(sprite);
    }
  }, {
    key: "display",
    value: function display() {
      this.displaySprites.all(function (sprite) {
        sprite.display();
      });
    }
  }, {
    key: "update",
    value: function update() {
      this.updateSprites.all(function (sprite) {
        sprite.update();
      });
    }
  }, {
    key: "mouseMoved",
    value: function mouseMoved(x, y) {
      this.uiSprites.all(function (sprite) {
        sprite.over(x, y);
        sprite.out(x, y);
      });
    }
  }, {
    key: "mouseDown",
    value: function mouseDown(x, y) {
      this.uiSprites.all(function (sprite) {
        sprite.down(x, y);
      });
    }
  }, {
    key: "mouseUp",
    value: function mouseUp(x, y) {
      this.uiSprites.all(function (sprite) {
        sprite.up(x, y);
      });
    }
  }]);

  return Scene;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var SceneManager = /*#__PURE__*/function (_Manager) {
  _inherits(SceneManager, _Manager);

  var _super = _createSuper(SceneManager);

  function SceneManager() {
    _classCallCheck(this, SceneManager);

    return _super.apply(this, arguments);
  }

  _createClass(SceneManager, [{
    key: "add",
    value: function add(item, scenes, which) {
      if (typeof scenes == 'string') scenes = [scenes];

      for (var i = 0; i < scenes.length; i++) {
        if (which == 'display') this[scenes[i]].addToDisplay(item);else if (which == 'ui') this[scenes[i]].addUI(item);else this[scenes[i]].add(item);
      }
    }
  }]);

  return SceneManager;
}(Manager);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Sprite = /*#__PURE__*/function () {
  function Sprite(x, y, w, h) {
    _classCallCheck(this, Sprite);

    this.position = new Cool.Vector(x, y);
    this.width = w;
    this.height = h;
    this.debug = false;
    /* argument? isDebug ? */

    this.debugColor = "#00ffbb";
    this.collider = {
      position: new Cool.Vector(0, 0),
      width: this.width,
      height: this.height
    };
    this.isActive = true; // need a better name for this - disabled or something ... 

    this.center = false;
    this.mouseOver = false;
    this.waitToGoOut = false;
    this.clickStarted = false; // onOver, onOut, onUp, onDown, onClick
  }
  /* i don't know why the other reset exists,
  	need this to add new animtion in toilet2 */


  _createClass(Sprite, [{
    key: "resetSize",
    value: function resetSize() {
      this.width = undefined;
      this.height = undefined;
    }
  }, {
    key: "addAnimation",
    value: function addAnimation(animation, callback) {
      this.animation = animation;
      this.width = this.collider.width = this.animation.width;
      this.height = this.collider.height = this.animation.height;
    }
  }, {
    key: "fit",
    value: function fit(width) {
      if (this.width > width) this.scale(width / this.width);
    }
  }, {
    key: "setCollider",
    value: function setCollider(x, y, w, h) {
      this.collider.position.x = x;
      this.collider.position.y = y;
      this.collider.width = w;
      this.collider.height = h;
    }
    /* scaling sucks, should add this as sub class */

  }, {
    key: "scale",
    value: function scale(n) {
      /* need to wait for animation to load, do this later */
      this.width *= n;
      this.height *= n;
      this.collider.width *= n;
      this.collider.height *= n;
      this.animation.widthRatio *= n;
      this.animation.heightRatio *= n;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isActive) {
        if (this.jumpAmount != 0) {
          this.velocity.y += this.jumpAmount;
          this.jumpAmount = 0;
        }

        if (this.wiggleAmount > 0) {
          this.velocity.x += getRandom(-this.wiggleAmount, this.wiggleAmount);
        }

        this.position.add(this.velocity);

        if (!this.bounceAmount.zero()) {
          this.velocity.add(this.bouncAmount);
          this.bounceAmount = new Cool.Vector(0, 0);
        }
      }
    }
  }, {
    key: "drawDebug",
    value: function drawDebug() {
      gme.ctx.lineWidth = 1;
      gme.ctx.beginPath();
      gme.ctx.rect(this.xy.x + this.collider.position.x, this.xy.y + this.collider.position.y, this.collider.width, this.collider.height);
      var temp = gme.ctx.strokeStyle;
      gme.ctx.strokeStyle = this.debugColor;
      gme.ctx.stroke();
      gme.ctx.strokeStyle = temp;
    }
    /* better name for this ... */

  }, {
    key: "getCenter",
    value: function getCenter() {
      if (this.center) {
        return {
          x: this.position.x - (this.center ? this.width / 2 : 0),
          y: this.position.y - (this.center ? this.height / 2 : 0)
        };
      } else {
        return this.position;
      }
    }
  }, {
    key: "display",
    value: function display(isMap) {
      // if (this.debug) console.log(this.xy);
      // isMap should be editor specific parameter ... 
      if (this.isActive && (this.isOnScreen() || isMap)) {
        if (this.debug) this.drawDebug();

        if (this.animation && this.animation.loaded) {
          this.animation.draw(this.xy.x, this.xy.y);
          this.animation.update();
        }
      }

      if (this.displayFunc) this.displayFunc();
    }
  }, {
    key: "isOnScreen",
    value: function isOnScreen() {
      if (this.xy.x + this.width > 0 && this.xy.y + this.height > 0 && this.xy.x < gme.width && this.xy.y < gme.height) return true;else return false;
    }
  }, {
    key: "tap",
    value: function tap(x, y) {
      if (x > this.xy.x + this.collider.position.x && x < this.xy.x + this.collider.position.x + this.collider.width && y > this.xy.y + this.collider.position.y && y < this.xy.y + this.collider.position.y + this.collider.height) {
        return true;
      } else return false;
    }
  }, {
    key: "jump",
    value: function jump(amount) {
      this.jumpAmount += Math.min(-amount / 25, 10);
    }
  }, {
    key: "collide",
    value: function collide(other, callback) {
      if (this.isActive && other.isActive) {
        if (this.xy.x + this.collider.position.x < other.xy.x + other.collider.position.x + other.collider.width && this.xy.x + this.collider.position.x + this.collider.width > other.xy.x + other.collider.position.x && this.xy.y + this.collider.position.y < other.xy.y + other.collider.position.y + other.collider.height && this.xy.y + this.collider.position.y + this.collider.height > other.xy.y + other.collider.position.y) {
          if (callback) callback(this);
          return true;
        } else if (this.bounce) {
          // check next frame
          var nextpos = new Cool.Vector(this.xy.x, this.xy.y);
          nextpos.add(this.velocity);

          if (nextpos.x < other.position.x + other.width && nextpos.x + this.width > other.position.x && nextpos.y < other.position.y + other.size.y && nextpos.y + this.height > other.position.y) {
            var xoff = this.position.x + this.width - other.position.y;
            var yoff = this.position.y + this.height - other.position.y;

            if (Math.abs(xoff) < Math.abs(yoff)) {
              this.position.x = other.position.x - this.width;
            } else {
              this.position.y = other.position.y - this.height;
              this.bounceAmount.add(new Cool.Vector(0, yoff / 2));
            }

            if (callback) callback(this);
            return true;
          }

          return false;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: "outside",
    value: function outside(other) {
      var next = this.position.copy();
      var nextCollider = this.collider.position.copy();
      next.add(nextCollider);
      next.add(this.velocity);
      var nextSize = this.collider.size.copy();

      if (next.x < other.position.x + other.collider.position.x || next.x + nextSize.x > other.position.x + other.collider.position.x + other.collider.width || next.y < other.position.y + other.collider.position.y || next.y + nextSize.y > other.position.y + other.collider.position.y + other.collider.height) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "reset",
    value: function reset(widthMin, widthMax, heightMin, heightMax) {
      this.position.x = Cool.randomInt(widthMin, widthMax - this.width);
      this.position.y = Cool.randomInt(heightMin, heightMax);
    }
  }, {
    key: "over",
    value: function over(x, y) {
      if (this.isActive && this.tap(x, y) && !this.mouseOver && !this.waitToGoOut) {
        this.mouseOver = true;
        if (this.onOver) this.onOver();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "out",
    value: function out(x, y) {
      if (this.isActive && !this.tap(x, y) && (this.mouseOver || this.waitToGoOut)) {
        this.clickStarted = false;
        this.waitToGoOut = false;
        this.mouseOver = false;
        if (this.onOut) this.onOut();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "down",
    value: function down(x, y) {
      if (this.isActive && this.tap(x, y)) {
        this.clickStarted = true;
        this.waitToGoOut = true;
        if (this.onDown) this.onDown();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "up",
    value: function up(x, y) {
      if (this.isActive && this.tap(x, y) && this.clickStarted) {
        this.mouseOver = false;
        if (this.onUp) this.onUp();
        if (this.onClick) this.onClick();
        if (this.func) func();
        return true;
      } else {
        return false;
      }

      this.clickStarted = false;
    }
  }, {
    key: "xy",
    get: function get() {
      if (this.center) {
        return {
          x: this.position.x - (this.center ? this.width / 2 : 0),
          y: this.position.y - (this.center ? this.height / 2 : 0)
        };
      } else {
        return this.position;
      }
    }
  }]);

  return Sprite;
}();
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SpriteCollection = /*#__PURE__*/function () {
  function SpriteCollection(sprites) {
    _classCallCheck(this, SpriteCollection);

    this.sprites = sprites ? _toConsumableArray(sprites) : [];
  }

  _createClass(SpriteCollection, [{
    key: "sprite",
    value: function sprite(index) {
      return this.sprites[index];
    }
  }, {
    key: "remove",
    value: function remove(sprite) {
      this.sprites.splice(this.sprites.indexOf(sprite), 1);
    }
  }, {
    key: "add",
    value: function add(sprite) {
      this.sprites.push(sprite);
    } // loop 

  }, {
    key: "all",
    value: function all(callback) {
      for (var i = 0; i < this.sprites.length; i++) {
        callback(this.sprites[i], i);
      }
    }
  }, {
    key: "display",
    value: function display() {
      this.all(function (sprite) {
        sprite.display();
      });
    }
  }, {
    key: "length",
    get: function get() {
      return this.sprites.length;
    }
  }]);

  return SpriteCollection;
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Stats = /*#__PURE__*/function () {
  function Stats(ctx, labels) {
    var _this = this;

    _classCallCheck(this, Stats);

    this.ctx = ctx;
    this.ctx.font = 'lighter 11px sans-serif';
    this.stats = {};
    labels.forEach(function (label) {
      _this.stats[label] = [];
    });
  }

  _createClass(Stats, [{
    key: "create",
    value: function create(label) {
      this.stats[label] = [];
    }
  }, {
    key: "update",
    value: function update(label, time, prevTime) {
      this.stats[label].push(1000 / (time - prevTime));
      if (this.stats[label].length > 20) this.stats[label].shift();
    }
  }, {
    key: "draw",
    value: function draw() {
      // bg
      this.ctx.fillStyle = 'rgba(0,0,0,0.75)';
      this.ctx.fillRect(window.innerWidth - 65, 0, 50, 40);
      this.ctx.font = 'lighter 11px sans-serif';
      this.ctx.fillStyle = 'rgba(100,255,200)';
      var x = window.innerWidth - 60;
      var y = 15;

      for (var label in this.stats) {
        var stat = this.stats[label];
        var text = "".concat(label, " ").concat(Math.round(stat.reduce(function (n, s) {
          return n + s;
        }, 0) / stat.length));
        this.ctx.fillText(text, x, y);
        y += 20;
      }
    }
  }]);

  return Stats;
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Text = /*#__PURE__*/function () {
  function Text(x, y, msg, wrap, letters) {
    _classCallCheck(this, Text);

    this.x = Math.round(x);
    this.y = Math.round(y);
    this.lead = 35; // leading is space between lines

    this.track = 18; // tracking is space between letters

    this.msg = msg;
    this.wrap = wrap;
    this.isActive = true;
    this.letters = letters;
    this.breaks = [];
    this.setBreaks();
    this.count = 0;
    this.end = 0;
    this.hover = false;
    this.clickStarted = false;
  }

  _createClass(Text, [{
    key: "setPosition",
    value: function setPosition(x, y) {
      this.x = x;
      this.y = y;
    }
  }, {
    key: "setMsg",
    value: function setMsg(msg) {
      this.msg = msg;
      this.setBreaks();
    }
  }, {
    key: "setBreaks",
    value: function setBreaks() {
      /* 
      	set line breaks in message, 
      	based on message length, new line & return keys
      	waits for a space i guess?
      */
      var breakOnNextSpace = false; // wait for next space character

      var offset = 0; // 0 matches first i % this.wrap, then moves to accomodate added characters for spaces

      var prevBreak = false; // for space break followed by \n\r

      this.breaks = [];

      for (var i = 1; i < this.msg.length; i++) {
        prevBreak = false; // break on \n\r, check to make sure it didn't just break

        if (this.msg[i].match(/[\n\r]/g) && !prevBreak) {
          this.breaks.push(i);
          offset = i % this.wrap;
          breakOnNextSpace = false;
        } else if (i % this.wrap == offset && !breakOnNextSpace) {
          if (this.msg[i] == ' ') {
            this.breaks.push(i);
            prevBreak = true;
          } else breakOnNextSpace = true;
        } else if (this.msg[i] == ' ' && breakOnNextSpace) {
          this.breaks.push(i);
          offset = i % this.wrap;
          breakOnNextSpace = false;
          prevBreak = true;
        }
      }
    }
    /* animate text backward and forward, maybe need to update - maybe add animate/update method? */

  }, {
    key: "display",
    value: function display(countForward, countBackward, _x, _y) {
      if (this.isActive) {
        var len = countForward ? this.count : this.msg.length;
        var index = countBackward ? this.end : 0;
        var x = _x || this.x;
        var y = _y || this.y; // y -= this.breaks.length * this.lead;

        for (var i = index; i < len; i++) {
          var letter = this.msg[i]; // if (!letter.match(/[!a-zA-Z]/g)) console.log(letter);

          if (letter == ' ' || letter == '_') {
            x += this.track;
          } else if (letter == '\n' || letter == '\r') {// y += this.lead;
            // x = _x || this.x;
          } else {
            this.letters.state = letter;
            this.letters.draw(x, y);
            x += this.track;
          }

          if (this.breaks.indexOf(i) != -1) {
            y += this.lead;
            x = _x || this.x;
          }
        }

        if (this.count >= this.msg.length) this.end++;else this.count++;

        if (countBackward) {
          if (this.end >= this.msg.length) {
            this.end = 0;
            /* reset */

            this.count = 0;
            return true;
          }
        } else {
          if (this.end >= 5) {
            // how long to wait after completed text // hardcoded?
            this.end = 0;
            this.count = 0;
            return true; // ended
          }
        }
      }
    }
  }]);

  return Text;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TextButton = /*#__PURE__*/function (_UI) {
  _inherits(TextButton, _UI);

  var _super = _createSuper(TextButton);

  function TextButton(x, y, msg, wrap, letters) {
    var _this;

    _classCallCheck(this, TextButton);

    _this = _super.call(this, {
      x: x,
      y: y
    });
    _this.center = false;
    _this.text = new Text(_this.position.x, _this.position.y, msg, wrap, letters);

    _this.setCollider();

    return _this;
  }

  _createClass(TextButton, [{
    key: "setMsg",
    value: function setMsg(msg) {
      this.text.setMsg(msg);
      this.text.wrap = msg.length;
      this.setCollider();
    }
  }, {
    key: "setCollider",
    value: function setCollider() {
      this.width = this.collider.width = (this.text.wrap < this.text.msg.length ? this.text.wrap : this.text.msg.length) * this.text.track;
      this.height = this.collider.height = (this.text.breaks.length + 1) * this.text.letters.height;
    }
  }, {
    key: "display",
    value: function display() {
      _get(_getPrototypeOf(TextButton.prototype), "display", this).call(this);

      if (this.isActive) this.text.display();
      /* use setter for alive active? when is text button set to not alive? 
      	find TextButton */
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y) {
      this.position.x = x;
      this.position.y = y;
      this.text.setPosition(x, y);
    }
  }]);

  return TextButton;
}(UI);
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Texture = /*#__PURE__*/function () {
  function Texture(params, debug) {
    _classCallCheck(this, Texture);

    this.locations = params.locations || [];
    this.frame = params.frame || 'index';
    this.debug = debug;
    this.center = params.center || false;
    this.offset = new Cool.Vector(0, 0);
    if (params.animation) this.animation = params.animation;
  }

  _createClass(Texture, [{
    key: "addLocation",
    value: function addLocation(index, x, y) {
      this.animation.createNewState("f-".concat(index), index, index);
      var loc = new Cool.Vector(x, y);
      loc.i = index;
      this.locations.push(loc);
    }
  }, {
    key: "addLocations",
    value: function addLocations(locations) {
      var _this$locations;

      (_this$locations = this.locations).push.apply(_this$locations, _toConsumableArray(locations));

      for (var i = 0; i < this.locations.length; i++) {
        if (this.frame == 'index') {
          this.locations[i].i = i;
          this.animation.createNewState("f-".concat(i), i, i);
        } else if (this.frame == 'random') {
          this.animation.randomFrames = true;
        } else if (this.frame == 'randomIndex') {
          var randomIndex = Cool.randomInt(0, this.animation.endFrame);
          this.locations[i].i = randomIndex;
          this.animation.createNewState("f-".concat(randomIndex), randomIndex, randomIndex);
        }
      }
    }
  }, {
    key: "display",
    value: function display() {
      for (var i = 0; i < this.locations.length; i++) {
        var x = this.locations[i].x + this.offset.x;
        var y = this.locations[i].y + this.offset.y;

        if (this.center) {
          x -= this.animation.width / 2;
          y -= this.animation.height / 2;
        } //  figure out centering later, only draw textures on screen


        if (x + this.animation.width > 0 && x < gme.width && y + this.animation.height > 0 && y < gme.height) {
          if (this.locations[i].i) this.animation.state = "f-".concat(this.locations[i].i);
          this.animation.draw(x, y);
        }
      }
    }
  }, {
    key: "update",
    value: function update(offset) {
      // this.offset = offset;
      this.offset = offset.copy();
    }
  }]);

  return Texture;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Toggle = /*#__PURE__*/function (_Button) {
  _inherits(Toggle, _Button);

  var _super = _createSuper(Toggle);

  function Toggle(params, debug) {
    var _this;

    _classCallCheck(this, Toggle);

    _this = _super.call(this, params, debug);
    _this.toggled = false;
    return _this;
  }

  _createClass(Toggle, [{
    key: "toggle",
    value: function toggle(state) {
      if (!state) this.toggled = !this.toggled;else this.toggled = state == 'on' ? true : false;
      this.animation.state = this.toggled ? 'selected' : 'idle';
      if (this.func) this.func();
      this.waitToGoOut = false;
      this.mouseOver = false;
      this.clickStarted = false;
    }
  }, {
    key: "out",
    value: function out(x, y) {
      _get(_getPrototypeOf(Toggle.prototype), "out", this).call(this, x, y);

      this.animation.state = this.toggled ? 'selected' : 'idle';
    }
  }, {
    key: "up",
    value: function up(x, y) {
      _get(_getPrototypeOf(Toggle.prototype), "up", this).call(this);

      if (this.tap(x, y) && this.clickStarted) this.toggle();
    }
  }]);

  return Toggle;
}(Button);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var UI = /*#__PURE__*/function (_Sprite) {
  _inherits(UI, _Sprite);

  var _super = _createSuper(UI);

  function UI(params, debug) {
    var _this;

    _classCallCheck(this, UI);

    /* xy orientation to game window */
    var x = params.x;
    var y = params.y;
    if (x % 1 != 0) x = gme.width * x;
    /* decimal / percentage of window */

    if (x < 0) x = gme.width + x;
    /* negative x offset from right side */

    if (y % 1 != 0) y = gme.height * y;
    /* decimal / percentage of window */

    if (y < 0) y = gme.height + y;
    /* negative y offset from bottom */

    _this = _super.call(this, x, y);
    _this.debug = debug;
    _this.center = true;
    if (params.hidden) _this.isActive = false;
    /* hidden prob in garden json ...  */

    if (params.json) _this.addJSON(params.json);
    if (params.animation) _this.addAnimation(params.animation);

    if (params.states) {
      _this.animation.states = params.states;
      _this.animation.state = 'idle';
    }

    _this.scenes = params.scenes; // deprecate ? 

    if (params.func) _this.func = window[params.func];
    /* shouldnt be attached to window - fine for now */

    return _this;
  }

  return UI;
}(Sprite);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Area = /*#__PURE__*/function () {
  function Area(x, y, w, h, c) {
    _classCallCheck(this, Area);

    this.x = Math.round(x);
    this.y = Math.round(y);
    this.w = Math.max(Math.round(w), 1);
    this.h = Math.max(Math.round(h), 1);
    this.c = c;
  }

  _createClass(Area, [{
    key: "isInside",
    value: function isInside(x, y) {
      if (x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h) return true;else return false;
    }
  }]);

  return Area;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Node = /*#__PURE__*/function (_Area) {
  _inherits(Node, _Area);

  var _super = _createSuper(Node);

  function Node(x, y, w, h) {
    var _this;

    _classCallCheck(this, Node);

    _this = _super.call(this, x, y, w, h, Math.floor(random(255)));
    _this.paths = [];
    _this.walls = [];
    return _this;
  }

  _createClass(Node, [{
    key: "split",
    value: function split(min) {
      if (this.a || this.b) return false;
      var verticalSplit = Math.random() > this.w / (this.w + this.h);
      if (min > (verticalSplit ? this.h : this.w)) return false;
      var max = (verticalSplit ? this.h : this.w) - min;
      if (max < min) return false;
      var split = Math.floor(random(min, max));

      if (verticalSplit) {
        this.a = new Node(this.x, this.y, this.w, split);
        this.b = new Node(this.x, this.y + split, this.w, this.h - split);
      } else {
        this.a = new Node(this.x, this.y, split, this.h);
        this.b = new Node(this.x + split, this.y, this.w - split, this.h);
      }

      return true;
    }
  }, {
    key: "createRooms",
    value: function createRooms() {
      if (this.a || this.b) {
        if (this.a) this.a.createRooms();
        if (this.b) this.b.createRooms();
        if (this.a && this.b) this.createPath(this.a.getRoom(), this.b.getRoom());
      } else {
        var w = Math.floor(random(3, this.w - 2));
        var h = Math.floor(random(3, this.h - 2));
        var x = Math.floor(random(1, this.w - w - 1));
        var y = Math.floor(random(1, this.h - h - 1));
        this.room = new Room(x + this.x, y + this.y, w, h, 'plum');
      }
    }
  }, {
    key: "createWalls",
    value: function createWalls() {
      /* how to account for nested paths? */
      if (this.paths.length) {
        var rooms = [];
        if (this.a) rooms = rooms.concat(this.a.getRooms());
        if (this.b) rooms = rooms.concat(this.b.getRooms());

        for (var x = this.x; x < this.x + this.w; x++) {
          for (var y = this.y; y < this.y + this.h; y++) {
            var inRoom = false;

            for (var i = 0; i < rooms.length; i++) {
              if (rooms[i].isInside(x, y)) inRoom = true;
            }

            for (var _i = 0; _i < this.paths.length; _i++) {
              if (this.paths[_i].isInside(x, y)) inRoom = true;
            }

            if (!inRoom) this.walls.push(new Wall(x, y));
          }
        }
      } else {
        if (this.a) this.a.createWalls();
        if (this.b) this.b.createWalls();
      }
    }
  }, {
    key: "getRooms",
    value: function getRooms() {
      if (this.room) return [this.room];else {
        var a, b;
        if (this.a) a = this.a.getRooms();
        if (this.b) b = this.b.getRooms();
        if (!a && !b) return null;else if (!a) return [a];else if (!b) return [b];else return a.concat(b);
      }
    }
  }, {
    key: "getRoom",
    value: function getRoom() {
      if (this.room) return this.room;else {
        var a, b;
        if (this.a) a = this.a.getRoom();
        if (this.b) b = this.b.getRoom();
        if (!a && !b) return null;else if (!b) return a;else if (!a) return b;else return random(1) > 0.5 ? a : b;
      }
    }
  }, {
    key: "createPath",
    value: function createPath(a, b) {
      // remove +1 and -2 from tut, think its causing missing links
      // https://gamedevelopment.tutsplus.com/tutorials/how-to-use-bsp-trees-to-generate-game-maps--gamedev-12268
      var v1 = {
        x: Math.floor(random(a.x + 1, a.x + a.w - 2)),
        y: Math.floor(random(a.y + 1, a.y + a.h - 2))
      };
      var v2 = {
        x: Math.floor(random(b.x + 1, b.x + b.w - 2)),
        y: Math.floor(random(b.y + 1, b.y + b.h - 2))
      };
      var w = v2.x - v1.x;
      var h = v2.y - v1.y;

      if (w < 0) {
        if (h < 0) {
          if (random(1) > 0.5) {
            this.paths.push(new Path(v2.x, v1.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v2.x, v2.y, 1, Math.abs(h) + 1, 'gold'));
          } else {
            this.paths.push(new Path(v2.x, v2.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v1.x, v2.y, 1, Math.abs(h) + 1, 'gold'));
          }
        } else if (h > 0) {
          if (random(1) > 0.5) {
            this.paths.push(new Path(v2.x, v1.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v2.x, v1.y, 1, Math.abs(h) + 1, 'gold'));
          } else {
            this.paths.push(new Path(v2.x, v2.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v1.x, v1.y, 1, Math.abs(h), 'gold')); // 1 short
          }
        } else {
          this.paths.push(new Path(v2.x, v2.y, Math.abs(w) + 1, 1, 'gold'));
        }
      } else if (w > 0) {
        if (h < 0) {
          if (random(1) > 0.5) {
            this.paths.push(new Path(v1.x, v2.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v1.x, v2.y, 1, Math.abs(h) + 1, 'gold'));
          } else {
            this.paths.push(new Path(v1.x, v1.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v2.x, v2.y, 1, Math.abs(h) + 1, 'gold'));
          }
        } else if (h > 0) {
          if (random(1) > 0.5) {
            this.paths.push(new Path(v1.x, v1.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v2.x, v1.y, 1, Math.abs(h) + 1, 'gold'));
          } else {
            this.paths.push(new Path(v1.x, v2.y, Math.abs(w) + 1, 1, 'gold'));
            this.paths.push(new Path(v1.x, v1.y, 1, Math.abs(h) + 1, 'gold'));
          }
        } else {
          this.paths.push(new Path(v1.x, v1.y, Math.abs(w) + 1, 1, 'gold'));
        }
      } else {
        if (h < 0) {
          this.paths.push(new Path(v2.x, v2.y, 1, Math.abs(h) + 1, 'gold'));
        } else {
          this.paths.push(new Path(v1.x, v1.y, 1, Math.abs(h) + 1, 'gold'));
        }
      }
    }
  }, {
    key: "display",
    value: function display() {
      // super.display();
      if (typeof p5 !== 'undefined') {
        textSize(14);
        fill('blue');
        textAlign(LEFT, TOP);
        text("".concat(this.x, ",").concat(this.y), this.x * cell.w, this.y * cell.h);
      }

      if (this.room) this.room.display();
      if (this.a) this.a.display();
      if (this.b) this.b.display();

      for (var i = 0; i < this.paths.length; i++) {
        this.paths[i].display();
      }

      for (var _i2 = 0; _i2 < this.walls.length; _i2++) {
        this.walls[_i2].display();
      }
    }
  }]);

  return Node;
}(Area);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Map = /*#__PURE__*/function () {
  function Map(cols, rows, minNodeSize, maxNodeSize) {
    _classCallCheck(this, Map);

    this.cols = cols;
    this.rows = rows;
    this.minNodeSize = minNodeSize;
    this.maxNodeSize = maxNodeSize;
    this.nodes = [];
  }

  _createClass(Map, [{
    key: "build",
    value: function build(edgeBuffer) {
      this.walls = [];
      this.nodes.push(new Node(edgeBuffer.w, edgeBuffer.h, this.cols - edgeBuffer.w * 2, this.rows - edgeBuffer.h * 2));
      console.group('load map');
      console.time('nodes');
      var didSplit = true;

      while (didSplit) {
        didSplit = false;

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];

          if (!node.a && !node.b) {
            if (node.w > this.maxNodeSize && node.h > this.maxNodeSize || random(1) > 0.5) {
              if (node.split(this.minNodeSize)) {
                this.nodes.push(node.a);
                this.nodes.push(node.b);
                didSplit = true;
              }
            }
          }
        }

        ;
      }

      console.timeEnd('nodes');
      console.time('rooms');
      this.nodes[0].createRooms();
      console.timeEnd('rooms');
      console.time('walls');

      for (var x = 0; x < this.cols; x++) {
        for (var y = 0; y < this.rows; y++) {
          var inRoom = false;

          for (var _i = 0; _i < this.nodes.length; _i++) {
            if (this.nodes[_i].room) {
              if (this.nodes[_i].room.isInside(x, y)) inRoom = true;
            }

            for (var j = 0; j < this.nodes[_i].paths.length; j++) {
              if (this.nodes[_i].paths[j].isInside(x, y)) inRoom = true;
            }
          }

          if (!inRoom) this.walls.push(new Wall(x * cell.w, y * cell.h, 'green'));
        }
      }

      console.timeEnd('walls');
      /* walls takes 1500ms ... needs work 
      	wall time got longer after updates ... */

      console.groupEnd();
    }
  }]);

  return Map;
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Cursor = /*#__PURE__*/function () {
  function Cursor(states) {
    _classCallCheck(this, Cursor);

    this.states = states;
    this.elem = document.getElementById('cursor');
    this.x = 0;
    this.y = 0;
    this.isDown = false;
  }

  _createClass(Cursor, [{
    key: "down",
    value: function down() {
      this.isDown = true;
    }
  }, {
    key: "up",
    value: function up() {
      this.isDown = false;
    }
  }, {
    key: "state",
    set: function set(state) {
      if (this._state != state) {
        this._state = state;
        this.elem.src = this.states[state];
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return Cursor;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellButton = /*#__PURE__*/function (_Button) {
  _inherits(HellButton, _Button);

  var _super = _createSuper(HellButton);

  function HellButton() {
    var _this;

    _classCallCheck(this, HellButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    Object.assign(_assertThisInitialized(_this), buttonMixin);
    return _this;
  }

  return HellButton;
}(Button);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellGame = /*#__PURE__*/function (_Game) {
  _inherits(HellGame, _Game);

  var _super = _createSuper(HellGame);

  function HellGame() {
    var _this;

    _classCallCheck(this, HellGame);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.lvl = 0;
    return _this;
  }

  _createClass(HellGame, [{
    key: "scene",
    set: function set(scene) {
      if (scene != this.scenes._current) {
        this.scenes.current = scene;
        ui.cursor.state = 'interact';

        switch (scene) {
          case 'map':
            ui.cursor.state = 'walk';
            break;

          case 'loading':
            ui.message.x = leftAlign;
            ui.cursor.state = 'loading';
            break;

          case 'message':
            ui.message.x = leftAlign;
            break;

          case 'inventory':
            ui.message.x = centerAlign;
            break;
        }

        ui.arrow.isActive = false;
      }
    }
  }, {
    key: "currentScene",
    get: function get() {
      return this.scenes.current;
    }
  }, {
    key: "currentSceneName",
    get: function get() {
      return this.scenes._current;
    }
  }, {
    key: "lvlName",
    get: function get() {
      return this.lvl == 0 ? 'Purgatory' : "Ring of Hell ".concat(this.lvl);
    }
  }]);

  return HellGame;
}(Game);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellItem = /*#__PURE__*/function (_Entity) {
  _inherits(HellItem, _Entity);

  var _super = _createSuper(HellItem);

  function HellItem(x, y, animation, data, type) {
    var _this;

    _classCallCheck(this, HellItem);

    _this = _super.call(this, {
      x: x,
      y: y
    });

    _this.addAnimation(animation);

    _this.type = type;
    _this.name = data[0];
    _this.health = +data[1];
    _this.morality = +data[2];
    _this.hunger = +data[3];
    _this.speed = +data[4];
    _this.hungerRate = +data[5]; // skip prob - maybe put this first or last

    _this.quote = data[7]; // add mouse type to this, simplify

    _this.consumeString;
    if (type == 'food') _this.consumeString = 'Eat';else if (type == 'scripture') _this.consumeString = 'Read';
    return _this;
  }

  return HellItem;
}(Entity);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellMap = /*#__PURE__*/function (_Map) {
  _inherits(HellMap, _Map);

  var _super = _createSuper(HellMap);

  function HellMap() {
    var _this;

    _classCallCheck(this, HellMap);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    gme.scenes.map.add(_assertThisInitialized(_this));
    Object.assign(_assertThisInitialized(_this), itemMixin); // adds over, out, down, up

    return _this;
  }

  _createClass(HellMap, [{
    key: "build",
    value: function build(callback) {
      var _this2 = this;

      _get(_getPrototypeOf(HellMap.prototype), "build", this).call(this, {
        // cell buffer
        w: Math.ceil(gme.width / 2 / cell.w),
        h: Math.ceil(gme.height / 2 / cell.h)
      });

      this.roomCount = 0;
      this.nodes.forEach(function (node) {
        if (node.room) _this2.roomCount++;
      });
      this.items = new SpriteCollection();
      this.addItems('food');
      this.addItems('scripture');
      if (callback) callback();
    }
  }, {
    key: "prob",
    value: function prob(f) {
      f = f.replace(/p(?![a-z])/g, Cool.map(gme.lvl, 0, 28, 0, 1)); // console.log(f);

      return Function('return ' + f)().clamp(0, 1);
    }
  }, {
    key: "addItems",
    value: function addItems(type) {
      var itemCount = random(1, this.roomCount);
      var choices = [];
      var indexes = [];

      for (var i = 0; i < gme.data[type].entries.length; i++) {
        var prob = this.prob(gme.data[type].entries[i][6]); // this changes - make it json ....

        if (prob == 1) choices.push(i);else if (prob > 0) {
          for (var j = 0; j < prob * 100; j++) {
            indexes.push(i);
          }
        }
      }

      var choicesWhileCount = 0;

      while (choices.length < itemCount) {
        var index = Cool.random(indexes);
        if (!choices.includes(index)) choices.push(index);

        if (choicesWhileCount > 10) {
          debugger;
        }
      }

      choicesWhileCount = 0;

      while (choices.length > 0) {
        var node = Cool.random(this.nodes.filter(function (n) {
          return n.room;
        }));

        var _index = choices.pop();

        var itemData = gme.data[type].entries[_index];
        var c = node.room.getCell();
        var item = new MapItem(c.x * cell.w + Cool.random(-cell.w / 4, cell.w / 4), c.y * cell.h + Cool.random(-cell.h / 4, cell.h / 4), gme.anims[type][itemData[0]], itemData, type);
        this.items.add(item);

        if (choicesWhileCount > 10) {
          debugger;
        }
      }
    }
  }, {
    key: "add",
    value: function add(item) {
      this.items.add(item);
    }
  }, {
    key: "remove",
    value: function remove(item) {
      this.items.remove(item);
    }
  }, {
    key: "display",
    value: function display() {
      this.nodes[0].display();

      for (var i = 0; i < this.walls.length; i++) {
        this.walls[i].display();
      }

      this.items.display();
    }
  }, {
    key: "update",
    value: function update() {
      // only map uses offset ... 
      // const offset = {
      // 	x: -player.x + gme.width / 2,
      // 	y: -player.y + gme.height / 2 
      // };
      var offset = new Cool.Vector(-player.x + gme.width / 2, -player.y + gme.height / 2); // this.nodes[0].update(offset);

      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        if (node.room) node.room.update(offset);

        for (var j = 0; j < node.paths.length; j++) {
          node.paths[j].update(offset);
        }
      }

      for (var _i = 0; _i < this.walls.length; _i++) {
        this.walls[_i].update(offset);
      }

      var wallCollision = false;

      for (var _i2 = 0; _i2 < map.walls.length; _i2++) {
        var wall = map.walls[_i2];
        if (wall.collide(player)) wallCollision = true;
      }

      if (wallCollision) player.back();
      this.items.all(function (item) {
        item.update(offset);
      });
    }
  }]);

  return HellMap;
}( /*#__PURE__*/_wrapNativeSuper(Map));
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellMessage = /*#__PURE__*/function (_Text) {
  _inherits(HellMessage, _Text);

  var _super = _createSuper(HellMessage);

  function HellMessage(x, y, msg, wrap, letters) {
    var _this;

    _classCallCheck(this, HellMessage);

    _this = _super.call(this, x, y, msg, wrap, letters);
    _this.list = [];
    _this["continue"] = new HellTextButton(_this.x, _this.y, 'Click Here To Explore Purgatory', gme.anims.lettering.messages);
    gme.scenes.add(_assertThisInitialized(_this), ['message', 'loading', 'inventory', 'win'], 'display');
    gme.scenes.add(_this["continue"], ['inventory', 'message', 'win'], 'ui');

    _this["continue"].onClick = function () {
      if (_this.list.length == 0) {
        _this.set('');

        if (player.died) loadNextMap();else if (_this.next) _this.next();else gme.scene = 'map';
        _this.next = undefined;
      } else {
        _this.set(_this.list.shift());

        _this["continue"].check();
      }
    };

    return _this;
  }

  _createClass(HellMessage, [{
    key: "add",
    value: function add(msg) {
      var waitForSpace = false; // wait for a space or line break here ... 

      var nextBreak = this.wrap * 4;
      var start = 0;

      for (var i = 0; i < msg.length; i++) {
        if (i == start + nextBreak || waitForSpace) {
          if (msg[i].match(/[\n\r\s]/g)) {
            this.list.push(msg.substring(start, i));
            waitForSpace = false;
            start = i + 1;
          } else {
            waitForSpace = true;
          }
        } else if (start + nextBreak > msg.length) {
          this.list.push(msg.substring(start, msg.length));
          i = msg.length;
        }
      }

      if (!this.msg) this.set(this.list.shift());
    }
  }, {
    key: "set",
    value: function set(msg) {
      _get(_getPrototypeOf(HellMessage.prototype), "setMsg", this).call(this, msg);

      if (msg) {
        this.isActive = true;
        var returns = msg.match(/[\n\r]/g);
        var y = this.y + (this.breaks.length + 2 + (returns ? returns.length : 0)) * 35;
        this["continue"].setPosition(this.x, y);
        this["continue"].isActive = true;
      } else {
        this.active = false;
        this["continue"].isActive = false;
      }
    }
  }, {
    key: "display",
    value: function display() {
      _get(_getPrototypeOf(HellMessage.prototype), "display", this).call(this); // this.continue.display();

    }
  }]);

  return HellMessage;
}( /*#__PURE__*/_wrapNativeSuper(Text));
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var HellTextButton = /*#__PURE__*/function (_TextButton) {
  _inherits(HellTextButton, _TextButton);

  var _super = _createSuper(HellTextButton);

  function HellTextButton(x, y, msg, letters, cursorState, onClick) {
    var _this;

    _classCallCheck(this, HellTextButton);

    _this = _super.call(this, x, y, msg, msg.length, letters);
    _this.cursorState = cursorState || 'interact';
    if (onClick) _this.onClick = onClick;
    return _this;
  }

  _createClass(HellTextButton, [{
    key: "onOver",
    value: function onOver() {
      ui.cursor.state = this.cursorState;
      ui.arrow.isActive = true;
      ui.arrow.position.x = this.position.x + this.width;
      ui.arrow.position.y = this.position.y;
    }
  }, {
    key: "onOut",
    value: function onOut() {
      ui.cursor.state = gme.currentSceneName == 'map' ? 'walk' : 'interact';
      ui.arrow.isActive = false;
    }
  }, {
    key: "onDown",
    value: function onDown() {
      ui.cursor.state = 'click'; // ui arrow?
    }
  }, {
    key: "onUp",
    value: function onUp() {
      ui.cursor.state = gme.currentSceneName == 'map' ? 'walk' : 'interact';
      ui.arrow.isActive = false;
    }
  }, {
    key: "check",
    value: function check() {
      // for changed button that hasn't moved ... 
      if (this.tap(ui.cursor.x, ui.cursor.y)) ui.arrow.isActive = true;
    }
  }]);

  return HellTextButton;
}(TextButton);
"use strict";

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Inventory = /*#__PURE__*/function () {
  function Inventory() {
    _classCallCheck(this, Inventory);

    this.size = 3;
    this.maxSize = 9;
    this.x = 64;
    this.y = inventoryY;
    this.w = 128;
    this.h = 128;
    gme.scenes.inventory.addUI(this);
    Object.assign(this, itemMixin); // adds over, out, down, up

    this.label = new Text(3, 140, "Inventory", 9, gme.anims.lettering.metrics);
    this.items = new SpriteCollection();
    /* not an item collection, only display bazed on size */

    this.labels = [];

    for (var i = 0; i < this.maxSize; i++) {
      this.labels[i] = new Text(this.x + this.w * i - this.w / 2, this.y + Math.floor(i / 3) * this.h - this.h / 2, '' + i, 1, gme.anims.lettering.metrics);
    }
  }

  _createClass(Inventory, [{
    key: "add",
    value: function add(itemParams, name) {
      var _this = this;

      gme.scene = 'inventory';

      if (this.items.length < this.size) {
        this.items.add(_construct(PackItem, _toConsumableArray(itemParams)));
        ui.message.set("You picked up the ".concat(name, "."));
        this.items.all(function (item, index) {
          item.position.x = _this.x + _this.w * index;
          item.position.y = _this.y + Math.floor(index / 3) * _this.h;
        });
        return true;
      } else {
        gme.scene = 'message';
        ui.message.set('Your pack is full.');
        return false;
      }
    }
  }, {
    key: "remove",
    value: function remove(item) {
      this.items.remove(item);
    }
  }, {
    key: "display",
    value: function display() {
      this.label.display();

      for (var i = 0; i < this.size; i++) {
        this.labels[i].display();
      }

      this.items.display();
    }
  }]);

  return Inventory;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MapItem = /*#__PURE__*/function (_HellItem) {
  _inherits(MapItem, _HellItem);

  var _super = _createSuper(MapItem);

  function MapItem() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _classCallCheck(this, MapItem);

    _this = _super.call.apply(_super, [this].concat(args));
    _this.pickup = new HellTextButton(_this.position.x + _this.width / 2, _this.position.y, "Pick up ".concat(_this.name), gme.anims.lettering.messages);
    _this.pickup.isActive = false;

    _this.pickup.onClick = function () {
      if (inventory.add(args, _this.name)) {
        ui.arrow.isActive = false; // global update for this? 

        map.remove(_assertThisInitialized(_this));
      }
    };

    _this.consume = new HellTextButton(_this.position.x + _this.width / 2, _this.position.y + 35, "".concat(_this.consumeString, " ").concat(_this.name), gme.anims.lettering.messages, _this.type == 'food' ? 'eat' : 'interact');
    _this.consume.isActive = false;

    _this.consume.onClick = function () {
      map.remove(_assertThisInitialized(_this));
      player.consume(_assertThisInitialized(_this), _this.type);
    };

    _this.ui = new SpriteCollection([_this.pickup, _this.consume]);
    return _this;
  }

  _createClass(MapItem, [{
    key: "display",
    value: function display() {
      _get(_getPrototypeOf(MapItem.prototype), "display", this).call(this);

      this.ui.display();
    }
  }, {
    key: "update",
    value: function update(offset) {
      _get(_getPrototypeOf(MapItem.prototype), "update", this).call(this, offset);

      if (this.collide(player)) {
        this.pickup.setPosition(this.position.x + this.width / 2, this.position.y - 35);
        this.consume.setPosition(this.position.x + this.width / 2, this.position.y);
        this.pickup.isActive = true;
        this.consume.isActive = true;
      } else {
        this.pickup.isActive = false;
        this.consume.isActive = false;
      }
    }
  }, {
    key: "over",
    value: function over(x, y) {
      this.ui.all(function (ui) {
        return ui.over(x, y);
      });
    }
  }, {
    key: "out",
    value: function out(x, y) {
      this.ui.all(function (ui) {
        return ui.out(x, y);
      });
    }
  }, {
    key: "down",
    value: function down(x, y) {
      this.ui.all(function (ui) {
        return ui.down(x, y);
      });
    }
  }, {
    key: "up",
    value: function up(x, y) {
      this.ui.all(function (ui) {
        return ui.up(x, y);
      });
    }
  }]);

  return MapItem;
}(HellItem);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var PackItem = /*#__PURE__*/function (_HellItem) {
  _inherits(PackItem, _HellItem);

  var _super = _createSuper(PackItem);

  function PackItem() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _classCallCheck(this, PackItem);

    _this = _super.call.apply(_super, [this].concat(args));
    _this.displayInventory = false; // gme.scenes.add(this, 'inventory', 'ui');

    Object.assign(_assertThisInitialized(_this), buttonMixin); // adds default onOver, onOut, onDown

    _this.consume = new HellTextButton(centerAlign, inventoryY - 35, "".concat(_this.consumeString, " ").concat(_this.name), gme.anims.lettering.messages, _this.type == 'food' ? 'eat' : 'interact');
    _this.consume.isActive = false;

    _this.consume.onClick = function () {
      player.consume(_assertThisInitialized(_this), _this.type);
      inventory.remove(_assertThisInitialized(_this));
    };

    _this.drop = new HellTextButton(centerAlign, inventoryY, "Drop ".concat(_this.name), gme.anims.lettering.messages);
    _this.drop.isActive = false;

    _this.drop.onClick = function () {
      inventory.remove(_assertThisInitialized(_this));

      var dropItem = _construct(MapItem, args);

      dropItem.setPosition(player.x, player.y);
      map.add(dropItem);
      gme.scene = 'map';
    };

    _this.ui = new SpriteCollection([_this.consume, _this.drop]);
    return _this;
  }

  _createClass(PackItem, [{
    key: "display",
    value: function display() {
      _get(_getPrototypeOf(PackItem.prototype), "display", this).call(this);

      this.ui.display();
    }
  }, {
    key: "onClick",
    value: function onClick() {
      var onOff = !this.displayInventory;
      inventory.items.all(function (item) {
        return item.toggleInventoryDisplay(false);
      });
      this.toggleInventoryDisplay(onOff);
    }
  }, {
    key: "toggleInventoryDisplay",
    value: function toggleInventoryDisplay(onOff) {
      var _this2 = this;

      this.displayInventory = typeof onOff === "undefined" ? !this.displayInventoryUI : onOff;
      this.ui.all(function (ui) {
        ui.isActive = _this2.displayInventory;
      });
    }
  }, {
    key: "over",
    value: function over(x, y) {
      _get(_getPrototypeOf(PackItem.prototype), "over", this).call(this, x, y);

      this.ui.all(function (ui) {
        return ui.over(x, y);
      });
    }
  }, {
    key: "out",
    value: function out(x, y) {
      _get(_getPrototypeOf(PackItem.prototype), "out", this).call(this, x, y);

      this.ui.all(function (ui) {
        return ui.out(x, y);
      });
    }
  }, {
    key: "down",
    value: function down(x, y) {
      _get(_getPrototypeOf(PackItem.prototype), "down", this).call(this, x, y);

      this.ui.all(function (ui) {
        return ui.down(x, y);
      });
    }
  }, {
    key: "up",
    value: function up(x, y) {
      _get(_getPrototypeOf(PackItem.prototype), "up", this).call(this, x, y);

      this.ui.all(function (ui) {
        return ui.up(x, y);
      });
    }
  }]);

  return PackItem;
}(HellItem);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Path = /*#__PURE__*/function (_Room) {
  _inherits(Path, _Room);

  var _super = _createSuper(Path);

  function Path() {
    _classCallCheck(this, Path);

    return _super.apply(this, arguments);
  }

  _createClass(Path, [{
    key: "addTextureAnimation",
    value: function addTextureAnimation() {
      this.texture.animation = gme.anims.textures.grass;
    }
  }]);

  return Path;
}(Room);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Player = /*#__PURE__*/function (_Sprite) {
  _inherits(Player, _Sprite);

  var _super = _createSuper(Player);

  function Player(animation, x, y, debug) {
    var _this;

    _classCallCheck(this, Player);

    _this = _super.call(this, Math.round(x), Math.round(y));
    _this.x = Math.round(x);
    _this.y = Math.round(y);
    _this.prevXY = {
      x: _this.x,
      y: _this.y
    };
    _this.center = true;
    /* need better name */

    _this.debug = debug || false;
    _this.speed = new Cool.Vector(8, 8);

    _this.addAnimation(animation);

    _this.animation.state = 'idle';

    _this.setCollider(25, 6, 78, 90);

    _this.input = {
      right: false,
      up: false,
      left: false,
      down: false
    };
    _this.target = new Cool.Vector(0, 0);
    _this.metricCount = 0;
    _this.died = false;
    _this.health = 100;
    _this.morality = 0;
    _this.hunger = 0;
    _this.hungerRate = 0.5;
    _this.hungerLevel = 0;
    return _this;
  }

  _createClass(Player, [{
    key: "inputKey",
    value: function inputKey(key, state) {
      this.input[key] = state;
    }
  }, {
    key: "setTarget",
    value: function setTarget(x, y) {
      this.target.x = x;
      this.target.y = y;
      this.hunger += this.hungerRate; // what about key presses .... 
    }
  }, {
    key: "update",
    value: function update() {
      if (Math.abs(this.target.x) < this.speed.x) this.target.x = 0;
      if (Math.abs(this.target.y) < this.speed.y) this.target.y = 0;
      this.prevXY = {
        x: this.x,
        y: this.y
      };
      var state = this.animation.state.includes('idle') ? this.animation.state : Cool.random(['idle']);

      if (this.input.up || this.target.y < 0) {
        if (this.target.y < 0) this.target.y += this.speed.y;
        if (this.y > gme.bounds.top) this.y -= this.speed.y;
        state = 'right';
      }

      if (this.input.down || this.target.y > 0) {
        if (this.target.y > 0) this.target.y -= this.speed.y;
        if (this.y < gme.bounds.bottom) this.y += this.speed.y;
        state = 'left';
      }

      if (this.input.right || this.target.x > 0) {
        if (this.target.x > 0) this.target.x -= this.speed.x;
        if (this.x < gme.bounds.right) this.x += this.speed.x;
        state = 'right';
      }

      if (this.input.left || this.target.x < 0) {
        if (this.target.x < 0) this.target.x += this.speed.x;
        if (this.x > gme.bounds.left) this.x -= this.speed.x;
        state = 'left';
      }

      this.animation.state = state;

      if (!this.died) {
        if (this.metricCount == 200) {
          this.checkHunger();
          this.metricCount = 0;
        }

        this.metricCount++;
      }
    }
  }, {
    key: "back",
    value: function back() {
      this.target.x = 0;
      this.target.y = 0;
      this.x = this.prevXY.x;
      this.y = this.prevXY.y;
    }
  }, {
    key: "spawn",
    value: function spawn() {
      var pos = Cool.random(map.nodes.filter(function (node) {
        return node.room;
      })).room.getCell();
      player.x = pos.x * cell.w;
      player.y = pos.y * cell.h;
    }
  }, {
    key: "reborn",
    value: function reborn() {
      this.health = 100;
      this.metricCount = 0;
      ui.metrics.health.update();
      ui.metrics.level.update();
      this.died = false;
      this.speed.x = 8;
      this.speed.y = 8;
      this.target.x = 0;
      this.target.y = 0;
    }
  }, {
    key: "checkMorality",
    value: function checkMorality() {
      if (this.morality == 0) {
        ui.message.add("You hath been morally neutral.");
        ui.message.add("You will remain in ".concat(gme.lvl == 0 ? 'purgatory' : 'this ring of hell', "."));
      } else if (this.morality > 0) {
        if (gme.lvl <= 0) {
          gme.lvl == 0;
          gme.scene = 'win';
          ui.message.set('Play again');
          ui.message.next = loadMap;
        } else {
          gme.lvl -= 1;
          ui.message.add("You hath acted morally.");
          ui.message.add("You will move up to a previous ring of hell.");
        }
      } else {
        ui.message.add("You are a sinner.");
        ui.message.add("You will descend further into hell.");
        gme.lvl += 1;
      }
    }
  }, {
    key: "checkHealth",
    value: function checkHealth() {
      ui.metrics.health.update();

      if (this.health <= 0) {
        ui.message.add("You hath died.");
        this.died = true;
        this.checkMorality();
      }
    }
  }, {
    key: "checkHunger",
    value: function checkHunger() {
      if (Math.floor(player.hunger / 10) > this.hungerLevel) {
        this.hungerLevel = Math.floor(player.hunger / 10);

        if (this.hungerLevel > 2) {
          this.speed.x -= 1;
          this.speed.y -= 1;
        }

        gme.scene = 'message';
        /* 
        	this is insane 
        	has to be set before going to switch and potentially dying
        	other option is a set of states in the hell message ... also not appealing
        	well ... if the character died, regardless, has to rebuild map ... 
        */

        switch (this.hungerLevel) {
          case 1:
            ui.message.set('You feel a slight pang of hunger.');
            break;

          case 2:
            ui.message.set('Was that sound your stomach?');
            break;

          case 3:
            ui.message.set('Your stomach growled.');
            break;

          case 4:
            ui.message.set('Your stomach is twisting in pain.');
            break;

          case 5:
            ui.message.set('You are starting to feel weak.');
            break;

          case 6:
            ui.message.set('You are beginning to feel light headed.');
            break;

          case 7:
            ui.message.set('Your body is desparate for food.');
            break;

          case 8:
            ui.message.set('You starved to death.');
            this.died = true;
            this.checkMorality();
            break;
        }
      }
    }
  }, {
    key: "consume",
    value: function consume(item, type) {
      this.typeString;

      switch (type) {
        case 'food':
          this.typeString = 'ate';
          break;

        case 'scripture':
          this.typeString = 'read';
          break;
      }

      gme.scene = 'message'; // reset speed immediately, make this more complicated later

      this.speed.x = 8;
      this.speed.y = 8;
      ui.message.set("You ".concat(this.typeString, " the ").concat(item.name, "."));
      ui.message.add(item.quote);
      this.health = Math.min(100, this.health + item.health);
      if (item.health != 0) ui.message.add("Your health hath ".concat(item.health > 0 ? 'increased' : 'decreased', "."));
      this.hunger = Math.max(0, this.hunger - item.hunger);
      if (item.hunger > 0) ui.message.add("Your hunger hath abated.");
      this.hungerRate = Math.max(0.1, this.hungerRate + item.hungerRate);
      this.morality += item.morality;
      if (item.morality != 0) ui.message.add("You hath ".concat(item.morality > 0 ? 'acted morally' : 'sinned', "."));
      this.speed.x += item.speed;
      this.speed.y += item.speed;
      ui.metrics.morality.update();
      this.checkHealth();
    }
  }]);

  return Player;
}(Sprite);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Room = /*#__PURE__*/function (_Area) {
  _inherits(Room, _Area);

  var _super = _createSuper(Room);

  function Room() {
    var _this;

    _classCallCheck(this, Room);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    var locations = [];

    for (var _x = _this.x; _x < _this.x + _this.w; _x++) {
      for (var _y = _this.y; _y < _this.y + _this.h; _y++) {
        locations.push({
          x: _x * cell.w,
          y: _y * cell.h
        });
      }
    }

    _this.texture = new Texture({
      frame: 'randomIndex',
      center: true
    }, true);

    _this.addTextureAnimation();

    _this.texture.addLocations(locations);

    _this.debug = true;
    _this.takenCells = [];
    return _this;
  }

  _createClass(Room, [{
    key: "addTextureAnimation",
    value: function addTextureAnimation() {
      this.texture.animation = gme.anims.textures.dirt;
    }
  }, {
    key: "getCell",
    value: function getCell() {
      var x = Cool.randomInt(this.x, this.x + this.w - 1);
      var y = Cool.randomInt(this.y, this.y + this.h - 1);
      var whileCount = 0;

      while (this.takenCells.filter(function (c) {
        return c.x == x && c.y == y;
      }).length) {
        x = Cool.randomInt(this.x, this.x + this.w);
        y = Cool.randomInt(this.y, this.y + this.h);
        whileCount++;

        if (whileCount > 10) {
          debugger;
          loadMap();
          return;
        }
      }

      this.takenCells.push({
        x: x,
        y: y
      });
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "display",
    value: function display() {
      this.texture.display();

      if (this.debug) {
        gme.ctx.globalAlpha = mapAlpha;
        var sz = 20;
        gme.ctx.fillStyle = this.debug;
        gme.ctx.strokeStyle = this.debug;
        gme.ctx.fillRect(this.x * sz, this.y * sz, this.w * sz, this.h * sz);
        gme.ctx.fillStyle = 'white';
        gme.ctx.font = "".concat(sz / 2, "px sans-serif");
        gme.ctx.fillText("".concat(this.x, ",").concat(this.y), this.x * sz, this.y * sz + 10);
        gme.ctx.globalAlpha = 1.0;
      }
    }
  }, {
    key: "update",
    value: function update(offset) {
      this.texture.update(offset);
    }
  }]);

  return Room;
}(Area);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var UIMetric = /*#__PURE__*/function (_Text) {
  _inherits(UIMetric, _Text);

  var _super = _createSuper(UIMetric);

  function UIMetric(x, y, callback) {
    var _this;

    _classCallCheck(this, UIMetric);

    var msg = callback();
    _this = _super.call(this, x, y, msg, msg.length, gme.anims.lettering.metrics);
    _this.callback = callback;
    gme.scenes.add(_assertThisInitialized(_this), ['map', 'inventory', 'message'], 'display');
    return _this;
  }

  _createClass(UIMetric, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(UIMetric.prototype), "setMsg", this).call(this, this.callback());

      this.wrap = this.msg.length;
      this.setBreaks();
    }
  }]);

  return UIMetric;
}( /*#__PURE__*/_wrapNativeSuper(Text));
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Wall = /*#__PURE__*/function (_Sprite) {
  _inherits(Wall, _Sprite);

  var _super = _createSuper(Wall);

  function Wall(x, y, debug) {
    var _this;

    _classCallCheck(this, Wall);

    _this = _super.call(this, x * cell.w, y * cell.h, cell.w, cell.h);
    _this.center = true; // this.debug = true;

    _this.origin = new Cool.Vector(x, y); // this.origin = { x: x, y: y };

    _this.texture = new Texture({
      frame: 'index',
      center: true,
      animation: gme.anims.textures.walls
    }, false); // indexes based on probably move through animation frames, higher frame number deeper in hell 

    var indexes = [];

    for (var i = gme.lvl * 2, len = gme.lvl + Cool.random(5, 10); i < len; i++) {
      var p = 1 - (i - gme.lvl) / len; // probability

      for (var j = 0; j < Math.floor(p * 10); j++) {
        indexes.push(i);
      }
    }

    for (var _i = 0, numItems = Cool.random(2, 5); _i < numItems; _i++) {
      _this.texture.addLocation(Cool.random(indexes), x + Cool.random(-cell.w / 3, cell.w / 3), y + Cool.random(-cell.h / 3, cell.h / 3));
    }

    return _this;
  }

  _createClass(Wall, [{
    key: "display",
    value: function display() {
      _get(_getPrototypeOf(Wall.prototype), "display", this).call(this);

      this.texture.display();
    }
  }, {
    key: "update",
    value: function update(offset) {
      this.position = this.origin.copy().add(offset.copy()); // this.position.x = this.origin.x + offset.x;
      // this.position.y = this.origin.y + offset.y;

      this.texture.update(offset);
    }
  }]);

  return Wall;
}(Sprite);
"use strict";

/*
	default cursor states for buttons and interactives
*/
var buttonMixin = {
  onOver: function onOver() {
    ui.cursor.state = 'interact';
  },
  onOut: function onOut() {
    ui.cursor.state = gme.currentSceneName == 'map' ? 'walk' : 'interact';
  },
  onDown: function onDown() {
    ui.cursor.state = 'click';
  },
  onUp: function onUp() {
    ui.cursor.state = gme.currentSceneName == 'map' ? 'walk' : 'interact';
  }
};
"use strict";

/*
	used by PackItem and MapItem to add ui mouse events for scene ui updates
	also used by HellMap and Inventory
*/
var itemMixin = {
  over: function over(x, y) {
    this.items.all(function (item) {
      return item.over(x, y);
    });
  },
  out: function out(x, y) {
    this.items.all(function (item) {
      return item.out(x, y);
    });
  },
  down: function down(x, y) {
    this.items.all(function (item) {
      return item.down(x, y);
    });
  },
  up: function up(x, y) {
    this.items.all(function (item) {
      return item.up(x, y);
    });
  }
};